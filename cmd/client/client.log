------
./cli.go:

package main

import (
	"errors"
	"fmt"
	"io"
	"net"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/chzyer/readline"
)

// command represents an action the client can execute.
type command struct {
	help    string
	handler func(c *cli, args string) error
}

// cli holds the client's state and dependencies.
type cli struct {
	conn              net.Conn
	rl                *readline.Instance
	rlConfig          *readline.Config // Store the config to re-initialize
	isAuthenticated   bool
	currentUser       string
	currentCollection string
	commands          map[string]command
	connMutex         sync.Mutex // Mutex to protect the connection during autocompletion
}

// newCLI creates a new client instance.
func newCLI(conn net.Conn) *cli {
	c := &cli{
		conn: conn,
	}
	c.commands = c.getCommands()
	return c
}

// run initializes readline and the client's main loop.
func (c *cli) run(user, pass *string) error {
	c.rlConfig = &readline.Config{
		Prompt:          "> ",
		HistoryFile:     "/tmp/readline_history.tmp",
		AutoComplete:    c.getCompleter(),
		InterruptPrompt: "^C",
		EOFPrompt:       "exit",
	}

	var err error
	c.rl, err = readline.NewEx(c.rlConfig)
	if err != nil {
		return fmt.Errorf("failed to initialize readline: %w", err)
	}
	defer c.rl.Close()

	// Automatic authentication if flags are provided
	if *user != "" && *pass != "" {
		fmt.Println(colorInfo("Attempting automatic login for user '%s'...", *user))
		if err := c.handleLogin(fmt.Sprintf("%s %s", *user, *pass)); err != nil {
			fmt.Println(colorErr("Automatic login failed. Please login manually."))
			os.Exit(1)
		}
	}

	if !c.isAuthenticated {
		fmt.Println(colorInfo("Please login using: login <username> <password>"))
	}

	return c.mainLoop()
}

// mainLoop is the client's heart, reading and processing commands.
func (c *cli) mainLoop() error {
	// Defines the mapping from short, contextual aliases to their full command names.
	contextualAliases := map[string]string{
		"set":    "collection item set",
		"get":    "collection item get",
		"delete": "collection item delete",
		"update": "collection item update",
		"list":   "collection item list",
		"query":  "collection query",
	}

	for {
		var promptParts []string
		if c.isAuthenticated && c.currentUser != "" {
			promptParts = append(promptParts, c.currentUser)
		}
		if c.currentCollection != "" {
			promptParts = append(promptParts, c.currentCollection)
		}

		var finalPrompt string
		if len(promptParts) > 0 {
			finalPrompt = strings.Join(promptParts, "/") + "> "
		} else {
			finalPrompt = "> "
		}
		c.rl.SetPrompt(colorPrompt(finalPrompt))

		// Read user input.
		input, err := c.rl.Readline()
		if err != nil {
			if errors.Is(err, readline.ErrInterrupt) {
				if len(input) == 0 {
					break // Exit with Ctrl+C on an empty line.
				}
				continue
			} else if errors.Is(err, io.EOF) {
				break // Exit with Ctrl+D.
			}
			return err
		}

		input = strings.TrimSpace(input)
		if input == "" {
			continue
		}

		cmd, args := getCommandAndRawArgs(input)

		// Prioritize resolving contextual aliases when a collection is in use.
		if c.currentCollection != "" {
			var resolvedCmd string // This will hold the full command name if an alias is found.
			isContextual := false

			if cmd == "index" {
				parts := strings.Fields(args)
				if len(parts) > 0 {
					// Attempt to construct the full command, e.g., "collection index create".
					potentialFullCmd := fmt.Sprintf("collection index %s", parts[0])
					if _, found := c.commands[potentialFullCmd]; found {
						resolvedCmd = potentialFullCmd
						args = strings.Join(parts[1:], " ") // Update args to exclude the subcommand.
						isContextual = true
					}
				}
			} else {
				// Check for other direct aliases like "get", "list", etc.
				if potentialFullCmd, isAlias := contextualAliases[cmd]; isAlias {
					if _, found := c.commands[potentialFullCmd]; found {
						resolvedCmd = potentialFullCmd
						// 'args' is already correct from the initial split.
						isContextual = true
					}
				}
			}

			// If a contextual alias was successfully resolved, overwrite the original command.
			if isContextual {
				cmd = resolvedCmd
			}
		}

		// Find the handler for the (potentially resolved) command.
		handler, found := c.commands[cmd]

		if !found {
			// This was corrected in a previous step, ensure it uses Printf
			fmt.Printf("%s", colorErr("Error: Unknown command. Type 'help' for commands.\n", cmd))
			continue
		}

		// Check for authentication before executing protected commands.
		if !c.isAuthenticated && cmd != "login" && cmd != "help" && cmd != "clear" && cmd != "exit" {
			fmt.Println(colorErr("Error: You must log in first. Use: login <username> <password>"))
			continue
		}

		// === START: TIMER IMPLEMENTATION ===

		// Start the timer right before executing the command.
		startTime := time.Now()

		// Execute the command handler.
		if err := handler.handler(c, args); err != nil {
			// Check if the error is the specific signal to exit the loop.
			if errors.Is(err, io.EOF) {
				break // Exit the loop gracefully.
			}
			// For all other errors, just print them.
			fmt.Println(colorErr("Command failed: ", err))
		}

		// Calculate the duration and print it.
		duration := time.Since(startTime)
		// Only show the timer for commands that are not purely local and instantaneous.
		if cmd != "clear" && cmd != "help" {
			fmt.Println(colorInfo("Request time: ", duration.Round(time.Millisecond)))
		}

		// === END: TIMER IMPLEMENTATION ===
	}
	fmt.Println(colorInfo("\nExiting client. Goodbye!"))
	return nil
}
------
./completer.go:

// cmd/client/completer.go

package main

import (
	"bytes"
	"fmt"
	"memory-tools/internal/protocol"
	"os"
	"strings"

	"github.com/chzyer/readline"
)

func (c *cli) getCompleter() readline.AutoCompleter {
	// If not authenticated, return the basic completer.
	if !c.isAuthenticated {
		return readline.NewPrefixCompleter(
			readline.PcItem("login"),
			readline.PcItem("help"),
			readline.PcItem("exit"),
			readline.PcItem("clear"),
		)
	}

	// ---- START OF MODIFICATION ----
	// If inside a collection, provide a CLEAN list of contextual commands.
	if c.currentCollection != "" {
		return readline.NewPrefixCompleter(
			// === Contextual Aliases ===
			readline.PcItem("list"),
			readline.PcItem("query"),
			readline.PcItem("get"),
			readline.PcItem("set"),
			readline.PcItem("delete"),
			readline.PcItem("update"),
			readline.PcItem("index",
				readline.PcItem("create"),
				readline.PcItem("delete"),
				readline.PcItem("list"),
			),

			// === Universal Commands ===
			// 'use' is kept to allow switching or exiting the context.
			readline.PcItem("use",
				readline.PcItem("exit"),
				readline.PcItemDynamic(c.fetchCollectionNames),
			),
			readline.PcItem("help"),
			readline.PcItem("exit"),
			readline.PcItem("clear"),
		)
	}
	// ---- END OF MODIFICATION ----

	// Default completer when NOT in a collection context.
	return readline.NewPrefixCompleter(
		readline.PcItem("user",
			readline.PcItem("create"),
			readline.PcItem("update"),
			readline.PcItem("delete"),
		),
		readline.PcItem("update", readline.PcItem("password")),
		readline.PcItem("backup"),
		readline.PcItem("restore"),
		readline.PcItem("set"),
		readline.PcItem("get"),
		readline.PcItem("use",
			readline.PcItem("exit"),
			readline.PcItemDynamic(c.fetchCollectionNames),
		),
		readline.PcItem("collection",
			readline.PcItem("create"),
			readline.PcItem("delete", readline.PcItemDynamic(c.fetchCollectionNames)),
			readline.PcItem("list"),
			readline.PcItem("index",
				readline.PcItem("create", readline.PcItemDynamic(c.fetchCollectionNames)),
				readline.PcItem("delete", readline.PcItemDynamic(c.fetchCollectionNames)),
				readline.PcItem("list", readline.PcItemDynamic(c.fetchCollectionNames)),
			),
			readline.PcItem("item",
				readline.PcItem("get", readline.PcItemDynamic(c.fetchCollectionNames)),
			),
			readline.PcItem("query", readline.PcItemDynamic(c.fetchCollectionNames)),
		),
		readline.PcItem("clear"),
		readline.PcItem("help"),
		readline.PcItem("exit"),
	)
}

func (c *cli) fetchCollectionNames(line string) []string {
	c.connMutex.Lock()
	defer c.connMutex.Unlock()

	const maxRetries = 3
	for attempt := 1; attempt <= maxRetries; attempt++ {
		var cmdBuf bytes.Buffer
		if err := protocol.WriteCollectionListCommand(&cmdBuf); err != nil {
			continue
		}
		if _, err := c.conn.Write(cmdBuf.Bytes()); err != nil {
			continue
		}

		statusByte := make([]byte, 1)
		if _, err := c.conn.Read(statusByte); err != nil {
			continue
		}
		status := protocol.ResponseStatus(statusByte[0])

		if _, err := protocol.ReadString(c.conn); err != nil {
			continue
		}

		dataBytes, err := protocol.ReadBytes(c.conn)
		if err != nil || status != protocol.StatusOk {
			continue
		}

		var collections []string
		// Use the existing 'json' package from utils.go if it were in the same package,
		// otherwise, import a json library here.
		if json.Unmarshal(dataBytes, &collections) != nil {
			continue
		}

		parts := strings.Fields(line)
		prefix := ""
		if len(parts) > 0 {
			// This logic might need adjustment depending on the exact completer behavior,
			// but for single-word suggestions, it's often fine.
			if len(parts) > 1 {
				prefix = parts[len(parts)-1]
			}
		}

		var suggestions []string
		for _, collection := range collections {
			if strings.HasPrefix(collection, prefix) {
				suggestions = append(suggestions, collection)
			}
		}
		// Add an empty suggestion for 'use' to allow exiting context.
		// Note: The library might handle this differently. This is one way.
		if strings.HasPrefix("", prefix) {
			suggestions = append(suggestions, "")
		}
		return suggestions
	}
	fmt.Fprintln(os.Stderr, colorErr("Warning: Could not fetch collection names for autocompletion after %d attempts.", maxRetries))
	return nil
}
------
./handlers.go:

package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"memory-tools/internal/protocol"
	"os"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/olekukonko/tablewriter"
)

func (c *cli) getCommands() map[string]command {
	return map[string]command{
		"login":                       {help: "login <username> <password> - Authenticate to the server", handler: (*cli).handleLogin},
		"help":                        {help: "help - Shows this help message", handler: (*cli).handleHelp},
		"exit":                        {help: "exit - Exits the client", handler: (*cli).handleExit},
		"clear":                       {help: "clear - Clears the screen", handler: (*cli).handleClear},
		"use":                         {help: "use [collection_name] - Set or clear the active collection", handler: (*cli).handleUse},
		"user create":                 {help: "user create <user> <pass> <perms_json|-|file:path> - Create a new user", handler: (*cli).handleUserCreate},
		"user update":                 {help: "user update <user> <perms_json|-|file:path> - Update a user's permissions", handler: (*cli).handleUserUpdate},
		"user delete":                 {help: "user delete <username> - Delete a user", handler: (*cli).handleUserDelete},
		"update password":             {help: "update password <user> <new_pass> - Change a user's password", handler: (*cli).handleChangePassword},
		"backup":                      {help: "backup - Triggers a manual server backup (root only)", handler: (*cli).handleBackup},
		"restore":                     {help: "restore <backup_name> - Restores from a backup (root only)", handler: (*cli).handleRestore},
		"set":                         {help: "set <key> <value_json> [ttl] - Set a key in the main store (root only)", handler: (*cli).handleMainSet},
		"get":                         {help: "get <key> - Get a key from the main store (root only)", handler: (*cli).handleMainGet},
		"collection create":           {help: "collection create <name> - Creates a new collection", handler: (*cli).handleCollectionCreate},
		"collection delete":           {help: "collection delete [name] - Deletes a collection", handler: (*cli).handleCollectionDelete},
		"collection list":             {help: "collection list - Lists all available collections", handler: (*cli).handleCollectionList},
		"collection index create":     {help: "collection index create [coll] <field> - Creates an index on a field", handler: (*cli).handleIndexCreate},
		"collection index delete":     {help: "collection index delete [coll] <field> - Deletes an index", handler: (*cli).handleIndexDelete},
		"collection index list":       {help: "collection index list [coll] - Lists indexes on a collection", handler: (*cli).handleIndexList},
		"collection item set":         {help: "collection item set [coll] [<key>] <value_json|-|file:path> [ttl] - Sets an item in a collection", handler: (*cli).handleItemSet},
		"collection item get":         {help: "collection item get [coll] <key> - Gets an item from a collection", handler: (*cli).handleItemGet},
		"collection item delete":      {help: "collection item delete [coll] <key> - Deletes an item from a collection", handler: (*cli).handleItemDelete},
		"collection item update":      {help: "collection item update [coll] <key> <patch_json|-|file:path> - Updates an item", handler: (*cli).handleItemUpdate},
		"collection item list":        {help: "collection item list [coll] - Lists all items in a collection (root only)", handler: (*cli).handleItemList},
		"collection query":            {help: "collection query [coll] <query_json|-|file:path> - Performs a complex query", handler: (*cli).handleQuery},
		"collection item set many":    {help: "collection item set many [coll] <json_array|-|file:path> - Sets multiple items", handler: (*cli).handleItemSetMany},
		"collection item update many": {help: "collection item update many [coll] <patch_json_array|-|file:path> - Updates multiple items", handler: (*cli).handleItemUpdateMany},
		"collection item delete many": {help: "collection item delete many [coll] <keys_json_array|-|file:path> - Deletes multiple items", handler: (*cli).handleItemDeleteMany},
	}
}

func (c *cli) handleLogin(args string) error {
	if c.isAuthenticated {
		return errors.New("you are already logged in")
	}
	parts := strings.Fields(args)
	if len(parts) != 2 {
		return errors.New("usage: login <username> <password>")
	}
	username, password := parts[0], parts[1]

	// Prepare and send the command
	var cmdBuf bytes.Buffer
	protocol.WriteAuthenticateCommand(&cmdBuf, username, password)

	if _, err := c.conn.Write(cmdBuf.Bytes()); err != nil {
		return fmt.Errorf("could not send login command: %w", err)
	}

	// Read the raw response from the server
	status, msg, _, err := c.readRawResponse()
	if err != nil {
		return err // Returns I/O errors, etc.
	}

	// Display the response consistently with other commands
	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"Status", "Message"})
	table.Append([]string{getStatusString(status), msg})
	table.Render()
	fmt.Println("---")

	// Handle logic based on the status
	if status == protocol.StatusOk {
		c.isAuthenticated = true
		c.currentUser = username

		// === FIX 1: Update the completer without the incorrect error check ===
		c.rlConfig.AutoComplete = c.getCompleter()
		c.rl.SetConfig(c.rlConfig) // No error check needed here

		// === FIX 2: Use Printf for correct formatting ===
		fmt.Printf(colorOK("√ Login successful. Welcome, %s!\n"), c.currentUser)
		return nil // Success
	}

	// If status was not OK, return an error to the main loop
	return errors.New("authentication failed")
}

func (c *cli) handleHelp(args string) error {
	fmt.Println(colorInfo("\nMemory Tools CLI Help"))
	fmt.Println("---------------------")
	fmt.Println("Commands are grouped by category. Use 'use <collection_name>' for contextual collections.")
	fmt.Println("JSON arguments can be provided directly, via '-' (editor), or 'file:/path/to/file.json'.")
	fmt.Println("---------------------")

	// Definir categorías y sus comandos asociados
	categories := map[string][]string{
		"Authentication":        {"login", "help", "exit", "clear"},
		"User Management":       {"user create", "user update", "user delete", "update password"},
		"Server Operations":     {"backup", "restore", "set", "get"},
		"Collection Management": {"collection create", "collection delete", "collection list", "use"},
		"Index Management":      {"collection index create", "collection index delete", "collection index list"},
		"Item Operations": {
			"collection item set", "collection item get", "collection item delete",
			"collection item update", "collection item list", "collection item set many",
			"collection item update many", "collection item delete many",
		},
		"Query": {"collection query"},
	}

	for category, cmds := range categories {
		fmt.Printf("\n%s%s%s\n", colorOK("== "), colorOK(category), colorOK(" =="))
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"Command", "Description"})
		table.SetAutoWrapText(false)
		for _, cmd := range cmds {
			details, exists := c.commands[cmd]
			if exists {
				table.Append([]string{cmd, details.help})
			}
		}
		table.Render()
	}
	fmt.Println("---------------------")
	return nil
}

func (c *cli) handleExit(args string) error {
	return io.EOF
}

func (c *cli) handleClear(args string) error {
	clearScreen()
	return nil
}

// cmd/client/handlers.go

func (c *cli) handleUse(args string) error {
	parts := strings.Fields(args)

	// Case 1: No arguments provided. This is an error.
	if len(parts) == 0 {
		return errors.New("you must specify a collection name, or use 'exit' to leave the current collection")
	}

	targetCollection := parts[0]

	// Case 2: The argument is 'exit'.
	if targetCollection == "exit" {
		// And we ARE in a collection, so we exit.
		if c.currentCollection != "" {
			fmt.Println(colorInfo("Exited collection mode."))
			c.currentCollection = ""
		} else {
			// And we are NOT in a collection, so we inform the user and do nothing else.
			fmt.Println(colorInfo("You are not currently in any collection."))
			return nil // Return to avoid unnecessarily updating the completer.
		}
	} else {
		// === START OF VALIDATION ===
		// Case 3: A collection name is provided. It must be validated.

		// We reuse the function from the completer to get the existing collections.
		collections := c.fetchCollectionNames("")
		if collections == nil {
			// This can happen if there's a connection issue while fetching the list.
			return errors.New("could not retrieve collection list from server")
		}

		found := false
		for _, collection := range collections {
			if collection == targetCollection {
				found = true
				break
			}
		}

		// If the collection was found, we switch the context.
		if found {
			c.currentCollection = targetCollection
			fmt.Println(colorInfo("Now using collection: ", c.currentCollection))
		} else {
			// If not, we return an error and DO NOT change the context.
			return fmt.Errorf("collection '%s' not found", targetCollection)
		}
		// === END OF VALIDATION ===
	}

	// Update the completer to reflect the change of context.
	c.rlConfig.AutoComplete = c.getCompleter()
	c.rl.SetConfig(c.rlConfig)

	return nil
}

func (c *cli) handleUserCreate(args string) error {
	parts := strings.SplitN(args, " ", 3)
	if len(parts) < 3 {
		return errors.New("usage: user create <username> <password> <permissions_json|-|file:path>")
	}
	username, password, jsonArg := parts[0], parts[1], parts[2]

	jsonPayload, err := c.getJSONPayload(jsonArg)
	if err != nil {
		return err
	}
	if !json.Valid(jsonPayload) {
		return errors.New("invalid permissions JSON format")
	}

	var cmdBuf bytes.Buffer
	protocol.WriteUserCreateCommand(&cmdBuf, username, password, jsonPayload)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("user create")
}

func (c *cli) handleUserUpdate(args string) error {
	parts := strings.SplitN(args, " ", 2)
	if len(parts) < 2 {
		return errors.New("usage: user update <username> <permissions_json|-|file:path>")
	}
	username, jsonArg := parts[0], parts[1]

	jsonPayload, err := c.getJSONPayload(jsonArg)
	if err != nil {
		return err
	}
	if !json.Valid(jsonPayload) {
		return errors.New("invalid permissions JSON format")
	}

	var cmdBuf bytes.Buffer
	protocol.WriteUserUpdateCommand(&cmdBuf, username, jsonPayload)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("user update")
}

func (c *cli) handleUserDelete(args string) error {
	parts := strings.Fields(args)
	if len(parts) != 1 {
		return errors.New("usage: user delete <username>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteUserDeleteCommand(&cmdBuf, parts[0])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("user delete")
}

func (c *cli) handleChangePassword(args string) error {
	parts := strings.Fields(args)
	if len(parts) != 2 {
		return errors.New("usage: update password <target_username> <new_password>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteChangeUserPasswordCommand(&cmdBuf, parts[0], parts[1])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("update password")
}

func (c *cli) handleBackup(args string) error {
	var cmdBuf bytes.Buffer
	protocol.WriteBackupCommand(&cmdBuf)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("backup")
}

func (c *cli) handleRestore(args string) error {
	parts := strings.Fields(args)
	if len(parts) != 1 {
		return errors.New("usage: restore <backup_name>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteRestoreCommand(&cmdBuf, parts[0])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("restore")
}

func (c *cli) handleMainSet(args string) error {
	parts := strings.SplitN(args, " ", 2)
	if len(parts) < 2 {
		return errors.New("usage: set <key> <value_json> [ttl]")
	}

	var cmdBuf bytes.Buffer
	protocol.WriteSetCommand(&cmdBuf, parts[0], []byte(parts[1]), 0)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("set")
}

func (c *cli) handleMainGet(args string) error {
	parts := strings.Fields(args)
	if len(parts) != 1 {
		return errors.New("usage: get <key>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteGetCommand(&cmdBuf, parts[0])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("get")
}

func (c *cli) handleCollectionCreate(args string) error {
	parts := strings.Fields(args)
	if len(parts) != 1 {
		return errors.New("usage: collection create <name>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteCollectionCreateCommand(&cmdBuf, parts[0])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection create")
}

func (c *cli) handleCollectionDelete(args string) error {
	collName, _, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}

	// Solicitar confirmación
	fmt.Printf(colorInfo("Are you sure you want to delete collection '%s'? (y/N): "), collName)
	input, err := c.rl.Readline()
	if err != nil {
		return err
	}
	if strings.ToLower(strings.TrimSpace(input)) != "y" {
		fmt.Println(colorInfo("Deletion cancelled."))
		return nil
	}

	var cmdBuf bytes.Buffer
	protocol.WriteCollectionDeleteCommand(&cmdBuf, collName)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection delete")
}

func (c *cli) handleCollectionList(args string) error {
	var cmdBuf bytes.Buffer
	protocol.WriteCollectionListCommand(&cmdBuf)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection list")
}

func (c *cli) handleIndexCreate(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	parts := strings.Fields(remainingArgs)
	if len(parts) != 1 {
		return errors.New("usage: collection index create [collection] <field_name>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteCollectionIndexCreateCommand(&cmdBuf, collName, parts[0])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection index create")
}

func (c *cli) handleIndexDelete(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	parts := strings.Fields(remainingArgs)
	if len(parts) != 1 {
		return errors.New("usage: collection index delete [collection] <field_name>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteCollectionIndexDeleteCommand(&cmdBuf, collName, parts[0])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection index delete")
}

func (c *cli) handleIndexList(args string) error {
	collName, _, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	var cmdBuf bytes.Buffer
	protocol.WriteCollectionIndexListCommand(&cmdBuf, collName)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection index list")
}

func (c *cli) handleItemSet(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}

	parts := strings.SplitN(remainingArgs, " ", 2)
	key, jsonArg := "", ""
	if len(parts) == 0 || parts[0] == "" {
		return errors.New("usage: collection item set [coll] [<key>] <value_json|-|file:path> [ttl]")
	}

	if len(parts) == 1 {
		key = uuid.New().String()
		jsonArg = parts[0]
	} else {
		if strings.HasPrefix(parts[1], "{") || strings.HasPrefix(parts[1], "[") || parts[1] == "-" || strings.HasPrefix(parts[1], "file:") {
			key = parts[0]
			jsonArg = parts[1]
		} else {
			key = uuid.New().String()
			jsonArg = remainingArgs
		}
	}

	jsonPayload, err := c.getJSONPayload(jsonArg)
	if err != nil {
		return fmt.Errorf("failed to parse JSON payload: %w", err)
	}
	if !json.Valid(jsonPayload) {
		return errors.New("invalid JSON format for value")
	}

	if len(strings.TrimSpace(string(jsonPayload))) == 0 {
		return errors.New("JSON payload cannot be empty")
	}

	var cmdBuf bytes.Buffer
	protocol.WriteCollectionItemSetCommand(&cmdBuf, collName, key, jsonPayload, 0*time.Second)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection item set")
}

func (c *cli) handleItemGet(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	parts := strings.Fields(remainingArgs)
	if len(parts) != 1 {
		return errors.New("usage: collection item get [collection] <key>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteCollectionItemGetCommand(&cmdBuf, collName, parts[0])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection item get")
}

func (c *cli) handleItemDelete(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	parts := strings.Fields(remainingArgs)
	if len(parts) != 1 {
		return errors.New("usage: collection item delete [collection] <key>")
	}
	var cmdBuf bytes.Buffer
	protocol.WriteCollectionItemDeleteCommand(&cmdBuf, collName, parts[0])
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection item delete")
}

func (c *cli) handleItemList(args string) error {
	collName, _, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	var cmdBuf bytes.Buffer
	protocol.WriteCollectionItemListCommand(&cmdBuf, collName)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection item list")
}

func (c *cli) handleItemUpdate(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	parts := strings.SplitN(remainingArgs, " ", 2)
	if len(parts) != 2 {
		return errors.New("usage: collection item update [coll] <key> <patch_json|-|file:path>")
	}
	key, jsonArg := parts[0], parts[1]

	jsonPayload, err := c.getJSONPayload(jsonArg)
	if err != nil {
		return err
	}

	var cmdBuf bytes.Buffer
	protocol.WriteCollectionItemUpdateCommand(&cmdBuf, collName, key, jsonPayload)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection item update")
}

func (c *cli) handleQuery(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	if remainingArgs == "" {
		return errors.New("usage: collection query [coll] <query_json|-|file:path>")
	}

	var jsonPayload []byte
	if remainingArgs == "interactive" {
		jsonPayload, err = c.getInteractiveJSONPayload()
	} else {
		jsonPayload, err = c.getJSONPayload(remainingArgs)
	}
	if err != nil {
		return err
	}

	var cmdBuf bytes.Buffer
	protocol.WriteCollectionQueryCommand(&cmdBuf, collName, jsonPayload)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection query")
}

func (c *cli) handleItemSetMany(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	if remainingArgs == "" {
		return errors.New("usage: collection item set many [coll] <json_array|-|file:path>")
	}

	jsonPayload, err := c.getJSONPayload(remainingArgs)
	if err != nil {
		return err
	}

	var cmdBuf bytes.Buffer
	protocol.WriteCollectionItemSetManyCommand(&cmdBuf, collName, jsonPayload)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection item set many")
}

func (c *cli) handleItemUpdateMany(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	if remainingArgs == "" {
		return errors.New("usage: collection item update many [coll] <patch_json_array|-|file:path>")
	}

	jsonPayload, err := c.getJSONPayload(remainingArgs)
	if err != nil {
		return err
	}

	var cmdBuf bytes.Buffer
	protocol.WriteCollectionItemUpdateManyCommand(&cmdBuf, collName, jsonPayload)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection item update many")
}

func (c *cli) handleItemDeleteMany(args string) error {
	collName, remainingArgs, err := c.resolveCollectionName(args)
	if err != nil {
		return err
	}
	if remainingArgs == "" {
		return errors.New("usage: collection item delete many [coll] <keys_json_array|-|file:path>")
	}

	jsonPayload, err := c.getJSONPayload(remainingArgs)
	if err != nil {
		return err
	}

	var keysToDelete []string
	if err := json.Unmarshal(jsonPayload, &keysToDelete); err != nil {
		return fmt.Errorf("invalid keys JSON array: %w", err)
	}

	var cmdBuf bytes.Buffer
	protocol.WriteCollectionItemDeleteManyCommand(&cmdBuf, collName, keysToDelete)
	c.conn.Write(cmdBuf.Bytes())
	return c.readResponse("collection item delete many")
}
------
./main.go:

package main

import (
	"crypto/tls"
	"crypto/x509"
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
)

func main() {
	log.SetFlags(0)

	usernamePtr := flag.String("u", "", "Username for authentication")
	passwordPtr := flag.String("p", "", "Password for authentication")
	flag.Parse()

	addr := "localhost:5876" // Default address
	if flag.NArg() > 0 {
		addr = flag.Arg(0)
	}

	// TLS Connection Configuration
	fmt.Println(colorInfo("Connecting to Memory Tools server at", addr))
	caCert, err := os.ReadFile("certificates/server.crt")
	if err != nil {
		log.Fatal(colorErr("Failed to read server certificate 'certificates/server.crt': %v", err))
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	tlsConfig := &tls.Config{
		RootCAs:    caCertPool,
		ServerName: strings.Split(addr, ":")[0],
	}

	// Connect using TLS
	conn, err := tls.Dial("tcp", addr, tlsConfig)
	if err != nil {
		log.Fatal(colorErr("Failed to connect via TLS to %s: %v", addr, err))
	}
	defer conn.Close()

	fmt.Println(colorOK("√ Connected securely."))

	// Initialize and run the client
	client := newCLI(conn)
	if err := client.run(usernamePtr, passwordPtr); err != nil {
		log.Fatal(colorErr("Client error: %v", err))
	}
}
------
./utils.go:

// cmd/client/utils.go

package main

import (
	"bytes"
	"encoding/base64"
	stdjson "encoding/json"
	"errors"
	"fmt"
	"io"
	"memory-tools/internal/protocol"
	"os"
	"os/exec"
	"runtime"
	"sort" // <-- IMPORT ADDED
	"strings"

	"github.com/chzyer/readline"
	"github.com/fatih/color"
	jsoniter "github.com/json-iterator/go"
	"github.com/olekukonko/tablewriter"
)

var json = jsoniter.ConfigCompatibleWithStandardLibrary

// Color definitions for the interface
var (
	colorOK     = color.New(color.FgGreen, color.Bold).SprintFunc()
	colorErr    = color.New(color.FgRed, color.Bold).SprintFunc()
	colorPrompt = color.New(color.FgMagenta).SprintFunc()
	colorInfo   = color.New(color.FgBlue).SprintFunc()
)

// getCommandAndRawArgs parses user input into a command and its arguments.
func getCommandAndRawArgs(input string) (string, string) {
	// List of multi-word commands, from longest to shortest.
	multiWordCommands := []string{
		"collection item update many", "collection item set many", "collection item delete many",
		"collection item update", "collection item set", "collection item get",
		"collection item delete", "collection item list", "collection index create",
		"collection index delete", "collection index list", "collection create",
		"collection delete", "collection list", "collection query", "user create",
		"user update", "user delete", "update password",
	}

	for _, mwCmd := range multiWordCommands {
		if strings.HasPrefix(input, mwCmd+" ") || input == mwCmd {
			return mwCmd, strings.TrimSpace(input[len(mwCmd):])
		}
	}

	parts := strings.SplitN(input, " ", 2)
	if len(parts) == 1 {
		return parts[0], ""
	}
	return parts[0], parts[1]
}

// clearScreen clears the terminal screen.
func clearScreen() {
	var cmd *exec.Cmd
	switch runtime.GOOS {
	case "windows":
		cmd = exec.Command("cmd", "/c", "cls")
	default:
		cmd = exec.Command("clear")
	}
	cmd.Stdout = os.Stdout
	_ = cmd.Run()
}

// getStatusString converts a ResponseStatus to a human-readable string.
func getStatusString(s protocol.ResponseStatus) string {
	switch s {
	case protocol.StatusOk:
		return "OK"
	case protocol.StatusNotFound:
		return "NOT_FOUND"
	case protocol.StatusError:
		return "ERROR"
	case protocol.StatusBadCommand:
		return "BAD_COMMAND"
	case protocol.StatusUnauthorized:
		return "UNAUTHORIZED"
	case protocol.StatusBadRequest:
		return "BAD_REQUEST"
	default:
		return "UNKNOWN"
	}
}

func (c *cli) getJSONFromEditor() ([]byte, error) {
	editor := os.Getenv("EDITOR")
	if editor == "" {
		if runtime.GOOS == "windows" {
			editor = "notepad"
		} else {
			editor = "vim"
		}
	}

	tmpfile, err := os.CreateTemp("", "memory-tools-*.json")
	if err != nil {
		return nil, fmt.Errorf("could not create temp file: %w", err)
	}
	defer os.Remove(tmpfile.Name())

	// Close readline to give terminal control to the editor
	c.rl.Close()

	fmt.Println(colorInfo("Opening editor (%s) for JSON input. Save and close the file to continue...", editor))

	cmd := exec.Command(editor, tmpfile.Name())
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	runErr := cmd.Run()

	// IMPORTANT: Re-initialize readline after the editor is closed.
	c.rl, err = readline.NewEx(c.rlConfig)
	if err != nil {
		return nil, fmt.Errorf("fatal: could not re-initialize readline: %w", err)
	}

	if runErr != nil {
		return nil, fmt.Errorf("error running editor: %w", runErr)
	}

	return os.ReadFile(tmpfile.Name())
}

func (c *cli) getJSONPayload(payload string) ([]byte, error) {
	if payload == "-" {
		return c.getJSONFromEditor()
	}
	if strings.HasPrefix(payload, "file:") {
		filePath := strings.TrimPrefix(payload, "file:")
		return os.ReadFile(filePath)
	}
	return []byte(payload), nil
}

func (c *cli) resolveCollectionName(args string) (string, string, error) {
	parts := strings.Fields(args)
	if len(parts) > 0 && !strings.HasPrefix(parts[0], "{") && !strings.HasPrefix(parts[0], "[") {
		return parts[0], strings.Join(parts[1:], " "), nil
	}
	if c.currentCollection != "" {
		return c.currentCollection, args, nil
	}
	return "", "", errors.New("no collection name provided and no collection is in use. Use 'use <collection_name>' or specify it in the command")
}

func (c *cli) readResponse(lastCmd string) error {
	c.connMutex.Lock()
	defer c.connMutex.Unlock()

	statusByte := make([]byte, 1)
	if _, err := io.ReadFull(c.conn, statusByte); err != nil {
		return fmt.Errorf("failed to read response status from server: %w", err)
	}
	status := protocol.ResponseStatus(statusByte[0])

	msg, err := protocol.ReadString(c.conn)
	if err != nil {
		return fmt.Errorf("failed to read response message from server: %w", err)
	}

	dataBytes, err := protocol.ReadBytes(c.conn)
	if err != nil {
		return fmt.Errorf("failed to read response data from server: %w", err)
	}

	// Estandarizar la salida
	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"Status", "Message"})
	table.Append([]string{getStatusString(status), msg})
	table.Render()

	if len(dataBytes) == 0 {
		fmt.Println("---")
		return nil
	}

	switch lastCmd {
	case "collection list", "collection index list", "collection item list", "collection query":
		if err := printDynamicTable(dataBytes); err != nil {
			fmt.Println(colorErr("Could not render table, falling back to JSON view."))
			var prettyJSON bytes.Buffer
			if err := stdjson.Indent(&prettyJSON, dataBytes, "  ", "  "); err == nil {
				fmt.Printf("  %s\n%s\n", colorInfo("Data:"), prettyJSON.String())
			} else {
				fmt.Printf("  %s %s\n", colorInfo("Data (Raw):"), string(dataBytes))
			}
		}
	default:
		var prettyJSON bytes.Buffer
		if err := stdjson.Indent(&prettyJSON, dataBytes, "  ", "  "); err == nil {
			fmt.Printf("  %s\n%s\n", colorInfo("Data:"), prettyJSON.String())
		} else {
			fmt.Printf("  %s %s\n", colorInfo("Data (Raw):"), string(dataBytes))
		}
	}
	fmt.Println("---")
	return nil
}

// ---- NEW FUNCTION ADDED ----
// printDynamicTable attempts to render a slice of JSON objects as a formatted table.
func printDynamicTable(dataBytes []byte) error {
	// Attempt 1: Try to unmarshal as an array of objects (multi-column table).
	var objectArrayResults []map[string]any
	if err := json.Unmarshal(dataBytes, &objectArrayResults); err == nil {
		if len(objectArrayResults) == 0 {
			return nil
		}
		headerSet := make(map[string]bool)
		for _, doc := range objectArrayResults {
			for key := range doc {
				headerSet[key] = true
			}
		}
		headers := make([]string, 0, len(headerSet))
		for key := range headerSet {
			headers = append(headers, key)
		}
		sort.Strings(headers)
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader(headers)
		table.SetAutoWrapText(false)
		for _, doc := range objectArrayResults {
			row := make([]string, len(headers))
			for i, header := range headers {
				if val, ok := doc[header]; ok {
					var valStr string
					switch v := val.(type) {
					case map[string]any, []any:
						jsonVal, _ := json.MarshalIndent(v, "", "  ")
						valStr = string(jsonVal)
					case nil:
						valStr = "(nil)"
					default:
						valStr = fmt.Sprintf("%v", v)
					}
					row[i] = valStr
				} else {
					row[i] = "(n/a)"
				}
			}
			table.Append(row)
		}
		table.Render()
		return nil
	}

	// Attempt 2: If that failed, try as a single object (Key-Value table).
	var singleObjectResult map[string]any
	if err := json.Unmarshal(dataBytes, &singleObjectResult); err == nil {
		if len(singleObjectResult) == 0 {
			return nil
		}
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"Key", "Value"})
		table.SetAutoWrapText(false)

		keys := make([]string, 0, len(singleObjectResult))
		for k := range singleObjectResult {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, k := range keys {
			val := singleObjectResult[k]
			var valStr string
			switch v := val.(type) {
			case map[string]any, []any:
				jsonVal, _ := json.MarshalIndent(v, "", "  ")
				valStr = string(jsonVal)
			case nil:
				valStr = "(nil)"
			default:
				// === START OF FIX ===
				// The value is likely a string. Check if it's Base64 encoded JSON.
				valStr = fmt.Sprintf("%v", v) // Default to the raw string
				if s, ok := v.(string); ok {
					// Attempt to decode from Base64
					if decodedBytes, err := base64.StdEncoding.DecodeString(s); err == nil {
						// If decoding succeeds, it might be JSON. Try to pretty-print it.
						var prettyJSON bytes.Buffer
						if stdjson.Indent(&prettyJSON, decodedBytes, "", "  ") == nil {
							valStr = prettyJSON.String()
						} else {
							// It was Base64 but not JSON, so show the decoded string.
							valStr = string(decodedBytes)
						}
					}
					// If Base64 decoding fails, we just keep the original string.
				}
				// === END OF FIX ===
			}
			table.Append([]string{k, valStr})
		}
		table.Render()
		return nil
	}

	// Attempt 3: If that also failed, try as an array of simple values (single-column table).
	var simpleArrayResults []any
	if err := json.Unmarshal(dataBytes, &simpleArrayResults); err == nil {
		if len(simpleArrayResults) == 0 {
			return nil
		}
		table := tablewriter.NewWriter(os.Stdout)
		table.SetHeader([]string{"Value"})
		for _, item := range simpleArrayResults {
			table.Append([]string{fmt.Sprintf("%v", item)})
		}
		table.Render()
		return nil
	}

	// Fallback: If all attempts fail, return an error to trigger pretty JSON printing.
	var initialErr error
	_ = json.Unmarshal(dataBytes, &objectArrayResults)
	return initialErr
}

func (c *cli) getInteractiveJSONPayload() ([]byte, error) {
	fmt.Println(colorInfo("Enter JSON key-value pairs (e.g., key=value). Type 'done' to finish or 'cancel' to abort."))
	var pairs []string
	for {
		c.rl.SetPrompt(colorPrompt("JSON> "))
		input, err := c.rl.Readline()
		if err != nil {
			return nil, err
		}
		input = strings.TrimSpace(input)
		if input == "done" {
			break
		}
		if input == "cancel" {
			return nil, errors.New("JSON input cancelled")
		}
		if input != "" {
			pairs = append(pairs, input)
		}
	}

	if len(pairs) == 0 {
		return nil, errors.New("no JSON data provided")
	}

	jsonMap := make(map[string]interface{})
	for _, pair := range pairs {
		parts := strings.SplitN(pair, "=", 2)
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid pair format: %s (use key=value)", pair)
		}
		key, value := strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])
		// Intenta parsear el valor como JSON; si falla, trata como string
		var jsonValue interface{}
		if err := json.Unmarshal([]byte(value), &jsonValue); err != nil {
			jsonValue = value
		}
		jsonMap[key] = jsonValue
	}

	return json.Marshal(jsonMap)
}

// readRawResponse reads the raw components of a response from the server.
// This is a helper to avoid code duplication in readResponse and handleLogin.
func (c *cli) readRawResponse() (protocol.ResponseStatus, string, []byte, error) {
	c.connMutex.Lock()
	defer c.connMutex.Unlock()

	statusByte := make([]byte, 1)
	if _, err := io.ReadFull(c.conn, statusByte); err != nil {
		return 0, "", nil, fmt.Errorf("failed to read response status from server: %w", err)
	}
	status := protocol.ResponseStatus(statusByte[0])

	msg, err := protocol.ReadString(c.conn)
	if err != nil {
		return status, "", nil, fmt.Errorf("failed to read response message from server: %w", err)
	}

	dataBytes, err := protocol.ReadBytes(c.conn)
	if err != nil {
		return status, msg, nil, fmt.Errorf("failed to read response data from server: %w", err)
	}

	return status, msg, dataBytes, nil
}
